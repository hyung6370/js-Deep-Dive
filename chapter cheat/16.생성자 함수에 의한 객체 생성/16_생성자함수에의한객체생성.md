# **16. 생성자 함수에 의한 객체 생성**

객체 리터럴에 의한 객체 생성 방식은 가장 일반적이며 간단한 객체 생성 방식이다.<br>
객체 리터럴 이외에 객체를 생성할 수 있는 방법에는 어떤한 것이 있을까?

## 🚀 **16.1 Object 생성자 함수**
`new` 연산자와 함께 `Object` 생성자 함수를 호출하면, 빈 객체를 생성해 반환한다.<br>
빈 객체를 생성한 이후 `프로퍼티` 또는 `메서드`를 추가해 객체를 완성할 수 있다.

```javascript
// 빈 객체의 생성
const person = new Object();

// 프로퍼티 추가
person.name = 'Kim';
person.sayHello = function() {
    console.log('Hi! My name is ' + this.name);
};

console.log(person);  // {name: 'Kim', sayHello: f}
person.sayHello();  // Hi! My name is Kim
```
- **생성자**(`constructor`) : `new` 연산자와 함꼐 호출해 객체(인스턴스)를 생성하는 함수
- **인스턴스**(`instance`) : 생성자 함수에 의해 생성된 함수

### **Javascript Built-in 생성자 함수**
```javascript
// String 생성자 함수에 의한 String 객체 생성
const strObj = new String('Lee');
console.log(typeof strObj); // object
console.log(strObj);        // String {"Lee"}

// Number 생성자 함수에 의한 Number 객체 생성
const numObj = new Number(123);
console.log(typeof numObj); // object
console.log(numObj);        // Number {123}

// Boolean 생성자 함수에 의한 Boolean 객체 생성
const boolObj= new Boolean(true);
console.log(typeof boolObj); // object
console.log(boolObj);        // Boolean {true}

// Function 생성자 함수에 의한 Function 객체(함수) 생성
const func = new Function('x', 'return x * x');
console.log(typeof func); // function
console.dir(func);        // ƒ anonymous(x)

// Array 생성자 함수에 의한 Array 객체(배열) 생성
const arr = new Array(1, 2, 3);
console.log(typeof arr); // object
console.log(arr);        // [1, 2, 3]

// RegExp 생성자 함수에 의한 RegExp 객체(정규 표현식) 생성
const regExp = new RegExp(/ab+c/i);
console.log(typeof regExp); // object
console.log(regExp);        // /ab+c/i

// Date 생성자 함수에 의한 Date 객체 생성
const date = new Date();
console.log(typeof date); // object
console.log(date);        // Mon May 04 2020 08:36:33 GMT+0900 (대한민국 표준시)
```
- 반드시 `Object` 생성자 함수를 사용해 빈 객체를 생성하는 것은 아니다.
- 객체를 생성하는 방법은 **객체 리터럴을 사용하는 것**이 더 간편하다.

<br>

___

## 🚀 **16.2 생성자 함수**
### 📌 **객체 리터럴에 의한 객체 생성 방식의 문제점**

```javascript
const circle1 = {
    radius: 5,
    getDiameter() {
        return 2 * this.radius;
    }
};

console.log(circle1.getDiameter());   // 10

const circle2 = {
    radius: 10,
    getDiameter() {
        return 2 * this.radius;
    }
};

console.log(circle2.getDiameter());  // 20
```
- 객체 리터럴에 의한 생성 방식은 직관적이고 편하지만, 단 하나의 객체만 생성한다.
    - 동일한 프로퍼티를 가지는 객체를 여러 개 생성해야 할 경우, 매번 같은 프로퍼티를 기술해야 하므로 비효율적이다.
- 객체는 프로퍼티를 통해 객체 고유의 상태를 표현한다.
- 메서드를 통해 상태 데이터인 프로퍼티를 참조하고 조작하는 동작을 표현한다.
    - 프로퍼티는 객체마다 프로퍼티 값이 다를 수 있지만, 메서드 내용이 동일한 경우가 일반적이다,
<br><br>

### 📌 **생성자 함수에 의한 객체 생성 방식의 장점**
생성자 함수에 의한 객체 생성 방식은 인스턴스를 생성하기 위한 템플릿처럼 여러 개를 간편하게 생성할 수 있다.
```javascript
// 생성자 함수
function Circle(radius) {
    // 생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다.
    this.radius = radius;
    this.getDiameter = function() {
        return 2 * this.radius;
    };
}

// 인스턴스의 생성
const circle1 = new Circle(5);  // 반지름이 5인 Circle 객체를 생성
const circle2 = new Circle(10);  // 반지름이 10인 Circle 객체를 생성

console.log(circle1.getDiameter());  // 10
console.log(circle2.getDiameter());  // 20
```
- **this** : 객체 자신의 프로퍼티나 메서드를 참조하기 위한 자기 참조 변수
    - `this`가 가리키는 값(`this` 바인딩) : **함수 호출 방식**에 따라 **동적**으로 결정된다.

|**함수 호출 방식**|**`this`가 가리키는 값(`this` binding)**|
|------|-----|
|일반 함수로서 호출|전역 객체|
|메서드로서 호출|메서드를 호출한 객체 (마침표 앞의 객체)|
|생성자 함수로서 호출|생성자 함수가 (미래에) 생성할 인스턴스|

```javascript
// 함수는 다양한 방식으로 호출될 수 있다.
function foo() {
    console.log(this);
}

// 일반적인 함수로서 호출
// 전역 객체는 브라우저 환경에서는 window, Node.js 환경에서는 global을 가리킨다.
foo();  // window

// 메서드로서 호출
const obj = { foo };  // ES6 프로퍼티 축약 표현
obj.foo();  // obj

// 생성자 함수로서 호출
const inst = new foo();  // inst
```
- 자바스크립트의 생성자 함수
    - 일반함수와 동일한 방법으로 생성자 함수 정의, `new` 연산자와 함께 호출 시 해당 함수가 생성자 함수로 동작하는 방식

<br>

### 📌 **생성자 함수의 인스턴스 생성 과정**
### 📌 **내부 메서드 `[[Call]]`과 `[[Construct]]`**
### 📌 **constructor와 non-constructor의 구분**
### 📌 **`new` 연산자**
### 📌 **new.target**