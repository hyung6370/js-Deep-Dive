# **10.원시 값과 객체의 비교**
자바스크립트가 제공하는 7가지 데이터 타입에는 `숫자`, `문자`, `불리언`, `null`, `undefined`, `심벌`, `객체타입`이 있다.
<br>-> **_원시 타입(primitive type) & 객체 타입(objective type)으로 구분 가능_**

- **원시 타입과 객체 타입의 차이**

||**원시 타입**|**객체 타입**|
|------|-----|-----|
|**값의 가변성**|원시 값 : 변경 불가능한 값<br>(원시 값 : 원시 타입의 값)|객체 : 변경 가능한 값<br>(객체 : 객체(참조) 타입의 값)|
|**저장되는 값**|원시 값을 변수에 할당할 경우,<br>변수(할당된 메모리 공간)에는 **실제 값** 저장|객체를 변수에 할당할 경우, <br>변수(할당된 메모리 공간)에는 **참조 값** 저장|
|**값의 다른 변수로의 할당**|원시 값을 갖는 변수를 다른 변수에 할당할 경우,<br>원본의 **원시 값이 복사되어 전달**됨<br>**값에 의한 전달**|객체를 가리키는 변수를 다른 변수에 할당할 경우,<Br>원본의 **참조 값이 복사되어 전달**됨<br>**참조에 의한 전달**|

<br>

___

## 🚀**10.1 원시값**
### 📌 **변경 불가능한 값** 
**원시 타입의 값**, 즉 **원시 값**은 **변경 불가능**한 값이다.<br>
-> 한번 생성된 원시 값은 _**읽기 전용 (read only) 값**_ 이기에 변경할 수 없다.

Q)_값을 변경할 수 없음_ 의 의미?<br>
- 변수와 값은 구분하여 생각해야 한다는 의미
- `변수` : 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름
- `값` : 변수에 저장된 데이터, 표현식이 평가되어 생성된 결과
    - `변경 불가능하다` : 변수가 아닌 값에 대한 진술
    - "원시값은 변경 불가능하다" : 원시 값 자체를 변경할 수 없음을 의미할 뿐, 변수 값을 변경할 수 없다는 의미는 아니다.
    - `변수` : 언제든 재할당을 통해 변수 값을 변경(교체)할 수 있다.

변수의 상대 개념 : `상수` -> 재할당이 금지된 변수
<br>상수 역시 값을 저장하기 위한 메모리 공간이 필요하므로 `변수`라고 할 수 있다.
<br>변수와의 차이는 `상수`는 단 한번만 할당이 허용되므로 변수 값을 변경(교체)할 수 없다는 점이다.
- `상수`와 `변경 불가능한 값`을 동일시하는 것은 옳지 않다.
- `상수` : **재할당이 금지된 변수**일 뿐

```javascript
// const 키워드를 사용해 선언한 변수는 재할당이 금지된다. 상수는 재할당이 금지된 변수일 뿐이다.
const o = {};

// const 키워드를 사용해 선언한 변수에 할당한 원시값(상수)은 변경할 수 없다.
// 하지만 const 키워드를 사용해 선언한 변수에 할당한 객체는 변경할 수 있다.
o.a = 1;
console.log(o); // {a: 1}
```
- 원시 값은 변경 불가능한 값, 즉 읽기 전용의 값이므로 어떤 일이 있어도 불변한다.
- 원시 값의 특성은 데이터의 신뢰성을 보장한다는 것이다.
<br><br>
- 원시 값을 할당한 변수에 새로운 원시값을 재할당할 경우,
<br>**_새로운 메모리 공간을 확보하고, 재할당한 원시 값을 저장한 후, 변수가 새롭게 재할당한 원시 값을 가리킨다._** <br>
-> 변수가 **참조하던 메모리 공간의 주소가 바뀐다.**

![](https://user-images.githubusercontent.com/66112716/213905411-9f069949-ef9f-4337-9cb6-903dad6eeb97.png)

변수가 참조하던 메모리 공간의 주소가 변경되는 이유?
<Br>**변수에 할당된 원시 값이 변경 불가능한 값이기 때문**
<br>-> 변수 값을 변경하기 위해 원시 값을 재할당할 경우, 아래와 같은 순서로 재할당된다.
<br>
1. 새로운 메모리 공간을 확보한다.
2. 재할당한 값을 저장한다.
3. 변수가 참조하던 메모리 공간의 주소를 변경한다.

-> 값의 이러한 특성 : **불변성(immutability)**
<br>**불변성을 가지는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없다.**
<br><br>
### 📌 **문자열과 불변성** 
- 문자열 : 0개 이상의 문자로 이루어진 집합, 1개의 문자는 2bytes의 메모리 공간에 저장

```javascript
// 문자열은 0개 이상의 문자들로 이루어진 집합이다.
var str1 = '';  // 0개의 문자로 이루어진 문자열 (빈 문자열)
var str2 = 'Hello';  // 5개의 문자로 이루어진 문자열
```

자바스크립트는 원시 타입인 **문자열 타입**을 제공한다. <br>
자바스크립트의 문자열은 **원시 타입**이며, **변경 불가능** 하다.

```javascript
var str = 'Hello';
str = 'world';
```
- 첫 번째 문의 실행
    - 문자열 `'Hello'` 생성
    - 식별자 `str` : 문자열 `Hello`가 저장된 메모리 공간의 첫 번째 메모리 셀 주소 가리킴
- 두 번째 문의 실행
    - 새로운 문자열 `world` 생성 (이전에 생성된 `Hello`를 수정하는 것 X)
    - 식별자 `str` : 새로 생겨난 문자열 `world` 가리킴 <br>
        -> `Hello`, `world` 는 모두 메모리에 존재<br>
        -> 식별자 `str` : 문자열 `Hello`를 가리키다가 `world`로 변경되었을 뿐

문자열의 한 문자를 변경해보자.
<br>문자열은 **유사 배역 객체**인 동시에 **이터러블**이므로 배열과 유사하게 각 문자에 접근할 수 있다.
- `유사 배열 객체` : 배열처럼 인텍스로 프로퍼티 값에 접근할 수 있고, `length` 프로퍼티를 가지는 객체를 말한다.
- 문자열은 마치 배열처럼 인덱스를 통해 각 문자에 접근할 수 있고, `length` 프로퍼티를 가지기에 유사 배열 객체이며, for문으로 순회 역시 가능하다.
- 원시 값을 객체처럼 사용하면 원시 값을 감싸는 **_래퍼 객체_** 로 자동 변환한다,

```javascript
var str = 'string';

// 문자열은 유사 배열이므로 배열과 유사하게 인덱스를 사용해 각 문자에 접근할 수 있다.
// 하지만 문자열은 원시 값이므로 변경할 수 없다. 이때 에러가 발생하지 않는다.
str[0] = '5';

console.log(str); // string
```
<br>

### 📌 **값에 의한 전달** 
```javascript
var score = 80;
var copy = score;

console.log(score);  // 80
console.log(copy);  // 80

score = 100;

console.log(score);  // 100
console.log(copy);  // ?
```

위의 경우 `score` 변수에 새로운 숫자 값 100을 재할당하면, `copy` 변수의 값은 어떻게 될까?
<br>-> 질문의 핵심 : "**변수에 변수를 할당했을 때, 무엇이 어떻게 전달되는가?**"
<br><br>
변수에 원시 값을 갖는 변수를 할당할 경우,
<br>할당하는 변수(`copy`)에는 할당되는 변수(`score`)의 원시 값이 복사되어 전달된다.
<Br>-> **값에 의한 전달**

```javascript
var score = 80;

// copy 변수에는 score 변수의 값 80이 복사되어 할당된다.
var copy = score;

console.log(score, copy); // 80  80
console.log(score === copy); // true
```
`score`와 `copy` 변수는 숫자 값 80을 가진다는 점에서 동일하나,<br>
`score`와 `copy` 변수의 값 80은 다른 메모리 공간에 저장된 별개의 값!
![](https://user-images.githubusercontent.com/66112716/213906335-97985b17-7b34-40c4-bfb1-7aaebe80a47e.png)

```javascript
var score = 80;

// copy 변수에는 score 변수의 값 80이 복사되어 할당된다.
var copy = score;

console.log(score, copy);    // 80  80
console.log(score === copy); // true

// score 변수와 copy 변수의 값은 다른 메모리 공간에 저장된 별개의 값이다.
// 따라서 score 변수의 값을 변경해도 copy 변수의 값에는 어떠한 영향도 주지 않는다.
score = 100;

console.log(score, copy);    // 100  80
console.log(score === copy); // false
```
![](https://user-images.githubusercontent.com/66112716/213906447-8bb59d03-6414-4044-bfdb-151febe0681f.png)
![](https://user-images.githubusercontent.com/66112716/213906458-b2febf40-e464-4beb-a866-b70f126d9edd.png)

📌 **값에 의한 전달**은 두 가지 방식으로 해석될 수 있다.
1. **값이 전달되는 것이 아니라, 메모리 주소가 전달되는 것이다.**
    - 변수와 같은 식별자는 값이 아닌 메모리 주소를 기억하고 있기 때문이다.
    - 단, 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있다.
2. **두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이다.**
    - 어느 한 쪽에서 재할당을 통해 값을 변경해도 서로 간섭할 수 없다.

<br>

___
## 🚀**10.2 객체**
